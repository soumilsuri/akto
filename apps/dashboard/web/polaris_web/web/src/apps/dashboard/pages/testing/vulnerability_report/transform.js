import { Badge, Box, Link } from "@shopify/polaris"
import func from "@/util/func"
import ShowListInBadge from "@/apps/dashboard/components/shared/ShowListInBadge"
import { operatorTypeOptions } from "@/apps/dashboard/pages/observe/api_collections/component/AdvancedSettingsComponent"

const reportTransform = {
    createVulnerableAPIsSeverity: (vulnerableTestingRunResults) => {
        const countMap = {
            CRITICAL: 0,
            HIGH: 0,
            MEDIUM: 0,
            LOW: 0,
        }

        vulnerableTestingRunResults.forEach(item => {
            const confidence = item.testResults.filter((result) => {
              return result.vulnerable
            }).map((result) => result.confidence)[0]
            countMap[confidence]++
        })

        const result = {
            "Critical": {
                "text": countMap.CRITICAL || 0,
                "color": func.getHexColorForSeverity("CRITICAL"),
                "filterKey": "Critical"
            },
            "High": {
                "text": countMap.HIGH || 0,
                "color": func.getHexColorForSeverity("HIGH"),
                "filterKey": "High"
            },
            "Medium": {
                "text": countMap.MEDIUM || 0,
                "color": func.getHexColorForSeverity("MEDIUM"),
                "filterKey": "Medium"
            },
            "Low": {
                "text": countMap.LOW || 0,
                "color": func.getHexColorForSeverity("LOW"),
                "filterKey": "Low"
            }
        }
        return result
    },

    getTotalUniqueApis: (vulnerableTestingRunResults) => {
        const uniqueApis = new Set()
        vulnerableTestingRunResults.forEach(item => {
            const endpointKey = `${item.apiInfoKey.apiCollectionId}-${item.apiInfoKey.method}-${item.apiInfoKey.url}`
            uniqueApis.add(endpointKey)
        })

        return uniqueApis.size
    },

    createVulnerabilityMap: (testingRunResults, categoryMap, subCategoryMap) => {
        let result = {}
        let categoryVsIssuesMap = {}
        let categoryVsApisCountMap = {}
        let issueVsVulMap = {}
        let aktoFindingsTableData = []
        let aktoRecommendationsData = []
        let high = 0
        let medium = 0
        let low = 0
        let totalIssuesCount = 0
        testingRunResults?.length > 0 && testingRunResults.forEach((testingRun) => {
            let testSubtype = testingRun?.testSubType
            let testInfo = subCategoryMap?.[testSubtype]

            if (!testInfo) {
                return
            }
            let severity = testInfo?.superCategory?.severity?._name
            let severityIndex = 0;
            switch (severity) {
                case 'HIGH':
                    ++high
                    severityIndex = 2
                    break;
                case 'MEDIUM':
                    ++medium
                    severityIndex = 1
                    break;
                case 'LOW':
                    ++low
                    severityIndex = 0
                    break;
                default:
                    break;
            }

            let vulnerabilities = issueVsVulMap[testSubtype]
            if (vulnerabilities === undefined) {
                vulnerabilities = JSON.parse(JSON.stringify(testInfo))
            }
            let vulnerableTestingRunResults = vulnerabilities["vulnerableTestingRunResults"]
            if (vulnerableTestingRunResults === undefined) {
                vulnerableTestingRunResults = []
            }
            vulnerableTestingRunResults.push(testingRun)
            vulnerabilities['vulnerableTestingRunResults'] = vulnerableTestingRunResults
            vulnerabilities['severityIndex'] = severityIndex
            issueVsVulMap[testSubtype] = vulnerabilities
        })
        result = {
            ...result,
            severitiesCount: { HIGH: high, MEDIUM: medium, LOW: low }
        }
        let severityMapForIssueCategory = {}
        for (const [testSubType, issue] of Object.entries(issueVsVulMap)) {
            const categoryName = issue.superCategory.name
            const severity = issue?.superCategory?.severity?._name

            if (!categoryName) {
                continue
            }

            let issuesList
            if (!categoryVsIssuesMap.hasOwnProperty(categoryName)) {
                issuesList = []
                categoryVsIssuesMap[categoryName] = issuesList
            } else {
                issuesList = categoryVsIssuesMap[categoryName]
            }

            issuesList.push(issue)

            let apisCount = 0
            if (!categoryVsApisCountMap.hasOwnProperty(categoryName)) {
                categoryVsApisCountMap[categoryName] = 0
            } else {
                apisCount = categoryVsApisCountMap[categoryName]
            }

            if(severityMapForIssueCategory.hasOwnProperty(categoryName)){
                let initialCount = severityMapForIssueCategory[categoryName][severity] || 0
                severityMapForIssueCategory[categoryName][severity] = initialCount + issue?.vulnerableTestingRunResults?.length 
            }else{
                severityMapForIssueCategory[categoryName] = {}
                severityMapForIssueCategory[categoryName][severity] = issue?.vulnerableTestingRunResults?.length 
            }

            apisCount += issue.vulnerableTestingRunResults.length
            categoryVsApisCountMap[categoryName] = apisCount

            //Add to akto recommendation
            if (issue.hasOwnProperty("remediation")) {
                aktoRecommendationsData.push({
                    title: issue.testName,
                    content:  issue.remediation
                })
            }
        }
        let totalTemplates = 0
        let graphArr = []

        const sortedCategories = Object.keys(categoryVsIssuesMap)
        .map(categoryName => ({
            categoryName,
            issueCount: categoryVsIssuesMap[categoryName].length
        }))
        .sort((a, b) => b.issueCount - a.issueCount)

        sortedCategories.slice(0, 5).forEach((categoryData, index) => {
            const { categoryName } = categoryData
            graphArr.push({
                text: categoryMap[categoryName]?.displayName,
                value: categoryVsApisCountMap[categoryName],
                color: '#B6B0FE'
            })
        })

        graphArr.sort((a, b) => b.value - a.value)

        let issueSno = 1
        const severityLevels = func.getAktoSeverities().reverse()
        Object.keys(categoryVsIssuesMap).forEach((categoryName, index) => {
            const issuesArr = categoryVsIssuesMap[categoryName]
            totalTemplates += issuesArr.length
            issuesArr.forEach((issue, issueIndex) => {
                const severity = func.getRunResultSeverity(issue.vulnerableTestingRunResults[0], subCategoryMap)
                const severityIndex = severityLevels.indexOf(severity)
                totalIssuesCount += issue.vulnerableTestingRunResults.length
                aktoFindingsTableData.push({
                    key: issueSno,
                    sno: issueSno++,
                    issueNameComp: <Box><Link onClick={(e) => e.stopPropagation()} url={`#${issue.testName}`} removeUnderline><p style={{whiteSpace: 'normal'}}>{issue.testName}</p></Link></Box>,
                    issueName: issue.testName,
                    issueDescriptionComp: <Box><p style={{whiteSpace: 'normal'}}>{(issue.issueDescription.replace(/^"|"$/g, ''))}</p></Box>,
                    issueDescription: issue.issueDescription,
                    apisAffected: issue.vulnerableTestingRunResults.length,
                    issueCategory: issue.superCategory.displayName,
                    issueCategoryComp: <Box><p style={{whiteSpace: 'normal'}}>{issue.superCategory.displayName}</p></Box>,
                    issueImpactComp: <div className={`badge-wrapper-${severity}`}>
                                        <Badge size="small" key={issueIndex+'impact'}>{func.toSentenceCase(severity)}</Badge>
                                    </div>,
                    issueImpact: severityIndex,
                })
            })
        })

        const AKTO_RECOMMENDATIONS_LIMIT = 10
        if (aktoRecommendationsData.length > AKTO_RECOMMENDATIONS_LIMIT) {
            aktoRecommendationsData = aktoRecommendationsData.slice(0, AKTO_RECOMMENDATIONS_LIMIT)
        }

        aktoFindingsTableData.sort((a, b) => b.issueImpact - a.issueImpact)
        aktoFindingsTableData.forEach((item, index) => {
            item.sno = index + 1
        })

        result = {
            ...result,
            totalApisTested: reportTransform.getTotalUniqueApis(testingRunResults) || 0,
            totalIssues: totalIssuesCount || 0,
            categoryMap: categoryMap,
            categoryVsIssuesMap: categoryVsIssuesMap,
            categoryVsApisCountMap: categoryVsApisCountMap,
            aktoFindingsTableData: aktoFindingsTableData,
            aktoRecommendations: aktoRecommendationsData,
            graphData: graphArr
        }

        return result
    },
    prepareReportTestConfigurationData: (testingRun, testingRunType, testRole, testingRunResultSummary) => {
        const initialReportTestConfigurationData = { general: [], testRole: [], advanced: [] }
        const reportTestConfigurationData = testingRun ? initialReportTestConfigurationData : {}

        const buildConfigurationSection = (section, dependency, buildSectionItem) => {
            if (section !== null && section !== undefined && dependency !== null && dependency !== undefined) {
                section.push(buildSectionItem(dependency));
            }
        };

        // ------- General Configuration
        const general = reportTestConfigurationData.general

        if (general) {
            buildConfigurationSection(general, testingRunType, (testingRunType) => ({
                id: "test-type",
                heading: "Test type",
                description: func.getRunTypeLabel(testingRunType, testingRun?.periodInSeconds),
            }));


            buildConfigurationSection(general, testingRun?.maxConcurrentRequests, (maxConcurrentRequests) => ({
                id: "max-concurrent-requests",
                heading: "Max concurrent requests",
                description: maxConcurrentRequests === -1 ? "Default" : maxConcurrentRequests,
            }));

            buildConfigurationSection(general, testingRun?.testingRunConfig?.overriddenTestAppUrl, (overriddenTestAppUrl) => ({
                id: "overridden-test-app-url",
                heading: "Host used for testing",
                description: overriddenTestAppUrl,
            }));

            buildConfigurationSection(general, testingRunResultSummary?.startTimestamp, (startTimestamp) => ({
                id: "test-start-time",
                heading: "Test started at",
                description: `${func.epochToDateTime(startTimestamp)}`,
            }));

            buildConfigurationSection(general, testingRunResultSummary?.endTimestamp, (endTimestamp) => ({
                id: "test-end-time",
                heading: "Test completed at",
                description: `${func.epochToDateTime(endTimestamp)}`,
            }));
        }

        // ------- Test Role Configuration
        const testRoleData = reportTestConfigurationData.testRole

        if (testRoleData) {
            buildConfigurationSection(testRoleData, testRole?.name, (name) => ({
                id: "test-role-name",
                heading: "Name",
                description: name,
            }));

            const authWithCondList = testRole?.authWithCondList
            if (authWithCondList && authWithCondList.length > 0) {
                authWithCondList.forEach((authWithCond, index) => {
                    buildConfigurationSection(testRoleData, authWithCond, (authWithCond) => {
                        const formattedAuthWithCondList = []

                        const authMechanismType = authWithCond.authMechanism?.type
                        formattedAuthWithCondList.push(`Type: ${authMechanismType}`)

                        const headerKVPairs = authWithCond.headerKVPairs
                        if (headerKVPairs && Object.keys(headerKVPairs).length > 0) {
                            const headerKey = Object.keys(headerKVPairs)[0]
                            const headerValue = headerKVPairs[headerKey]
                            formattedAuthWithCondList.push(`API header conditions: ${headerKey}=${headerValue}`)
                        }
                        return {
                            id: `auth-mechanism-${index + 1}`,
                            heading: `Auth mechanism - ${index + 1}`,
                            component: (
                                <ShowListInBadge
                                    itemsArr={formattedAuthWithCondList}
                                    status={"info"}
                                    useTooltip={true}
                                    wrap={true}
                                />
                            ),
                        }
                    })
                })
            }
        }

        // ------- Advanced Configuration
        const advanced = reportTestConfigurationData.advanced

        if (advanced) {
            const configsAdvancedSettings = testingRun?.testingRunConfig?.configsAdvancedSettings
            if (configsAdvancedSettings && configsAdvancedSettings.length > 0) {
                configsAdvancedSettings.forEach((advancedSetting) => {
                    buildConfigurationSection(advanced, advancedSetting, (advancedSetting) => {
                        const formattedOperationsGroupList = advancedSetting.operationsGroupList.map(operation => {
                            return operation.value.length > 0 ? `${operation.key}=${operation.value}` : `${operation.key}`
                        });

                        const operatorTypeOption = operatorTypeOptions[advancedSetting.operatorType] || {}

                        return {
                            id: advancedSetting.operatorType,
                            heading: operatorTypeOption?.heading,
                            component: (
                                <ShowListInBadge
                                    itemsArr={formattedOperationsGroupList}
                                    status={operatorTypeOption?.status}
                                    useTooltip={true}
                                    wrap={true}
                                />
                            ),
                        };
                    });
                })
            }
        }

        return reportTestConfigurationData
    }
}

export default reportTransform